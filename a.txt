Set-PSReadlineOption -HistorySaveStyle SaveNothing


def load_transactions(filename):
    """
    Load transactions from a text file.
    Each line in the file represents one transaction with space-separated items.
    Example:
        milk bread eggs
        bread butter
    """
    with open(filename) as f:
        s = f.read().strip().split("\n")
    # Split each line into a list of items
    transactions = [line.split() for line in s]
    return transactions


def get_support(itemset, transactions):
    """
    Calculate the support percentage of an itemset.
    Support = (number of transactions containing the itemset / total transactions) * 100
    """
    count = 0
    for t in transactions:
        # Check if itemset is a subset of transaction
        if set(itemset).issubset(set(t)):
            count += 1
        else:
            continue
    return (count / len(transactions)) * 100


def generate_candidates(Lk, k):
    """
    Generate candidate (k+1)-itemsets from frequent k-itemsets.
    This is the 'join' step of Apriori.
    - Only combine itemsets that share the first (k-1) elements.
    - Prune candidates if any of their subsets are not frequent.
    """
    candidates = []
    n = len(Lk)
    for i in range(n):
        for j in range(i + 1, n):
            # Join step: check if first (k-1) items are the same
            if Lk[i][:k - 1] == Lk[j][:k - 1]:
                # Union of two itemsets
                union = sorted(list(set(Lk[i]) | set(Lk[j])))
                if union not in candidates and len(union) == k + 1:
                    # Prune step: check all k-sized subsets are frequent
                    valid = True
                    for m in range(len(union)):
                        subset = union[:m] + union[m + 1:]
                        if subset not in Lk:
                            valid = False
                            break
                    if valid:
                        candidates.append(union)
    return candidates


def apriori(transactions, min_sup):
    """
    Apriori algorithm to find all frequent itemsets.
    Steps:
    1. Generate candidate 1-itemsets (C1).
    2. Keep those with support >= min_sup (L1).
    3. Iteratively generate candidates (Ck+1) from Lk and filter by support.
    4. Stop when no more frequent itemsets can be found.
    """
    # Step 1: Generate candidate 1-itemsets (C1)
    items = sorted({i for t in transactions for i in t})  # all unique items
    current_L = [[i] for i in items]  # initial L1 (1-itemsets)

    all_frequent = []  # to store all frequent itemsets
    k = 1
    while current_L:
        # Step 2: support check
        Lk = []
        for itemset in current_L:
            sup = get_support(itemset, transactions)
            if sup >= min_sup:
                Lk.append(itemset)
                all_frequent.append((itemset, sup))  # save with support

        # Step 3: generate next candidates (Ck+1)
        current_L = generate_candidates([i for i in Lk], k)
        k += 1

    return all_frequent


# ---------------- Example usage ----------------
transactions = load_transactions("td.txt")  # load dataset
min_sup = 50  # minimum support threshold in percentage

# Run Apriori
frequent_itemsets = apriori(transactions, min_sup)

# Print results
print("Frequent Itemsets (Apriori):")
for itemset, sup in frequent_itemsets:
    print(f"{itemset} -> {sup:.2f}%")
